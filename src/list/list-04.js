/**
 * @file List
 * 
 * 1. filter
 * 2. reject
 * 3. takeWhile
 * 4. dropWhile
 * 5. uniq
 * 6. uniqBy
 * 7. uniqWith
 * 8. zip
 * 9. zipObj
 * 10. zipWith
 */

// ========================== filter ========================
// 过滤出符合条件的成员
const isEven = n => n % 2 === 0;
R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}

// ========================= reject ========================
// filter的相反操作，返回结果为 R.filter 操作结果的补集
const isOdd = (n) => n % 2 === 1;
R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}

// ========================= takeWhile =====================
// 从前往后取出列表元素，直到遇到首个不满足 predicate 的元素为止。
// 取出的元素中不包含首个不满足 predicate 的元素。
// 若第二个参数自身存在 takeWhile 方法，则调用自身的 takeWhile 方法
// 若在列表位置中给出 transfomer，则用作 transducer 
const isNotFour = x => x !== 4;
R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'

// ======================== dropWhile ======================
// 对 list 从前向后删除满足 predicate 的头部元素，直到遇到第一个 falsy 值。
// predicate 需要作为第一个参数传入。
// 若第二个参数自身存在 dropWhile 方法，则调用自身的 dropWhile 方法。
// 若在 list 位置中给出 transfomer ，则用作 transducer 。
const lteTwo = x => x <= 2;
R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'

// ======================== uniq ===========================
// 列表去重操作。返回无重复元素的列表。通过 R.equals 函数进行相等性判断。
R.uniq([1, 1, 2, 1]); //=> [1, 2]
R.uniq([1, '1']);     //=> [1, '1']
R.uniq([[42], [42]]); //=> [[42]]

// ======================= uniqBy ==========================
// 返回无重复元素的列表。元素通过给定的函数的返回值以及 R.equals 进行相同性判断。
// 如果给定的函数返回值相同，保留第一个元素
R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]

// ======================= uniqWith =========================
// 返回无重复元素的列表。元素通过 predicate 进行相同性判断。
// 如果通过 predicate 判断两元素相同，保留第一个元素
const strEq = R.eqBy(String);
R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
R.uniqWith(strEq)([{}, {}]);       //=> [{}]
R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']

// ======================= zip ============================
// 将两个列表对应位置的元素组合，生成一个新的元素对列表。
// 生成的列表长度取决于较短的输入列表的长度
R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]

// ======================= zipObj =========================
// 将两个列表对应位置的元素作为键值对组合，生成一个新的键值对的列表。
// 生成的列表长度取决于较短的输入列表的长度
R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}

// ======================= zipWith ========================
// 将两个列表对应位置的元素通过一个函数处理，生成一个新的元素的列表。
// 生成的列表长度取决于较短的输入列表的长度
const f = (x, y) => {
  // ...
};
R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
//=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]